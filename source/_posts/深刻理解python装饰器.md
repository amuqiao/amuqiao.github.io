---
title: 深刻理解python装饰器
top: false
cover: false
toc: true
mathjax: true
date: 2021-03-19 21:19:26
img:
password:
summary:
tags:
- python
- 装饰器
categories:
- 后端
---

装饰器是程序开发中经常会⽤到的⼀个功能，⽤好了装饰器，开发效率如⻁添翼
<!-- more -->

# 一、示例代码

```
# coding=utf-8
def w1(func):
    print '--执行w1()--'
    def inner():
        print '--执行inner()--'
        func()
    print '--w1()执行结束--'
    return inner
@w1
def f1():
    print '--f1()--'

f1()

# 执行结果
--执行w1()--
--w1()执行结束--
--执行inner()--
--f1()--
```

# 二、执行过程

## 1.语法糖:@+函数名 

python解释器就会从上到下解释代码，步骤如下：
① def w1(func): ==>将w1函数加载到内存
② @w1
从表⾯上看解释器仅仅会解释这两句代码，因为函数在没有被调⽤之前其内部代码不会被执⾏。
但是`@w1`这⼀句代码⾥却有⼤⽂章，`@+函数名`是python的⼀种`语法糖`。

## 2.@w1内部执行过程

在@w1内部会执行下一步操作:
执行w1函数，并将@w1下面的函数作为w1函数的参数

```
@w1			# 等价于 f1=w1(f1)
def f1():   
	xxx 
```

此时f1已经不再指向原来的函数体，指向w1返回的新函数体。

## 3.python解释器执行顺序

从pthon解释器层面具体执行顺序:

```
def w1(func): # 将w1函数加载到内存
```

```
@w1 # 即执行w1(f1),在这里先存一个记录点，此时内存中并没有f1的定义，继续向下执行
```

```
def f1(): # 将f1函数加载到内存
```

```
@w1 # 此时才会真正执行f1 = w1(f1),将w1函数的返回值赋值给f1，f1指向新的函数体
```

# 三、补充说明

python解释器遇到`函数体()`才会去执行一个函数，遇到`def func()`和`func`不会去执行。

最后在来看一下代码的输出结果

```
@w1 # 执行f1=w1(f1)，w1函数被执行，所以w1函数体的的print会执行
def f1():
    print '--f1()--'

# 执行结果
--执行w1()--
--w1()执行结束--
```

```
f1() # 执行被装饰后的f1
# 执行结果
--执行inner()--
--f1()--
```